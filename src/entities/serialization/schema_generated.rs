// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

pub enum DrugOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Drug<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Drug<'a> {
    type Inner = Drug<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Drug<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Drug {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DrugArgs<'args>) -> flatbuffers::WIPOffset<Drug<'bldr>> {
      let mut builder = DrugBuilder::new(_fbb);
      builder.add_end_at(args.end_at);
      builder.add_init_at(args.init_at);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_INIT_AT: flatbuffers::VOffsetT = 6;
    pub const VT_END_AT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Drug::VT_NAME, None)
  }
  #[inline]
  pub fn init_at(&self) -> i64 {
    self._tab.get::<i64>(Drug::VT_INIT_AT, Some(0)).unwrap()
  }
  #[inline]
  pub fn end_at(&self) -> i64 {
    self._tab.get::<i64>(Drug::VT_END_AT, Some(0)).unwrap()
  }
}

pub struct DrugArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub init_at: i64,
    pub end_at: i64,
}
impl<'a> Default for DrugArgs<'a> {
    #[inline]
    fn default() -> Self {
        DrugArgs {
            name: None,
            init_at: 0,
            end_at: 0,
        }
    }
}
pub struct DrugBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DrugBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Drug::VT_NAME, name);
  }
  #[inline]
  pub fn add_init_at(&mut self, init_at: i64) {
    self.fbb_.push_slot::<i64>(Drug::VT_INIT_AT, init_at, 0);
  }
  #[inline]
  pub fn add_end_at(&mut self, end_at: i64) {
    self.fbb_.push_slot::<i64>(Drug::VT_END_AT, end_at, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DrugBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DrugBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Drug<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PathogenOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Pathogen<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pathogen<'a> {
    type Inner = Pathogen<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Pathogen<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Pathogen {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PathogenArgs<'args>) -> flatbuffers::WIPOffset<Pathogen<'bldr>> {
      let mut builder = PathogenBuilder::new(_fbb);
      builder.add_report_date(args.report_date);
      if let Some(x) = args.notes { builder.add_notes(x); }
      if let Some(x) = args.culture_source { builder.add_culture_source(x); }
      if let Some(x) = args.id_method { builder.add_id_method(x); }
      if let Some(x) = args.org_name { builder.add_org_name(x); }
      builder.add_organism_type(args.organism_type);
      builder.add_ribo_status(args.ribo_status);
      builder.add_hmbpp_status(args.hmbpp_status);
      builder.add_gram_status(args.gram_status);
      builder.finish()
    }

    pub const VT_GRAM_STATUS: flatbuffers::VOffsetT = 4;
    pub const VT_HMBPP_STATUS: flatbuffers::VOffsetT = 6;
    pub const VT_RIBO_STATUS: flatbuffers::VOffsetT = 8;
    pub const VT_ORG_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_ID_METHOD: flatbuffers::VOffsetT = 12;
    pub const VT_CULTURE_SOURCE: flatbuffers::VOffsetT = 14;
    pub const VT_ORGANISM_TYPE: flatbuffers::VOffsetT = 16;
    pub const VT_REPORT_DATE: flatbuffers::VOffsetT = 18;
    pub const VT_NOTES: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn gram_status(&self) -> u8 {
    self._tab.get::<u8>(Pathogen::VT_GRAM_STATUS, Some(0)).unwrap()
  }
  #[inline]
  pub fn hmbpp_status(&self) -> u8 {
    self._tab.get::<u8>(Pathogen::VT_HMBPP_STATUS, Some(0)).unwrap()
  }
  #[inline]
  pub fn ribo_status(&self) -> u8 {
    self._tab.get::<u8>(Pathogen::VT_RIBO_STATUS, Some(0)).unwrap()
  }
  #[inline]
  pub fn org_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Pathogen::VT_ORG_NAME, None)
  }
  #[inline]
  pub fn id_method(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Pathogen::VT_ID_METHOD, None)
  }
  #[inline]
  pub fn culture_source(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Pathogen::VT_CULTURE_SOURCE, None)
  }
  #[inline]
  pub fn organism_type(&self) -> u8 {
    self._tab.get::<u8>(Pathogen::VT_ORGANISM_TYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn report_date(&self) -> i64 {
    self._tab.get::<i64>(Pathogen::VT_REPORT_DATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn notes(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Pathogen::VT_NOTES, None)
  }
}

pub struct PathogenArgs<'a> {
    pub gram_status: u8,
    pub hmbpp_status: u8,
    pub ribo_status: u8,
    pub org_name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub id_method: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub culture_source: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub organism_type: u8,
    pub report_date: i64,
    pub notes: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for PathogenArgs<'a> {
    #[inline]
    fn default() -> Self {
        PathogenArgs {
            gram_status: 0,
            hmbpp_status: 0,
            ribo_status: 0,
            org_name: None,
            id_method: None,
            culture_source: None,
            organism_type: 0,
            report_date: 0,
            notes: None,
        }
    }
}
pub struct PathogenBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PathogenBuilder<'a, 'b> {
  #[inline]
  pub fn add_gram_status(&mut self, gram_status: u8) {
    self.fbb_.push_slot::<u8>(Pathogen::VT_GRAM_STATUS, gram_status, 0);
  }
  #[inline]
  pub fn add_hmbpp_status(&mut self, hmbpp_status: u8) {
    self.fbb_.push_slot::<u8>(Pathogen::VT_HMBPP_STATUS, hmbpp_status, 0);
  }
  #[inline]
  pub fn add_ribo_status(&mut self, ribo_status: u8) {
    self.fbb_.push_slot::<u8>(Pathogen::VT_RIBO_STATUS, ribo_status, 0);
  }
  #[inline]
  pub fn add_org_name(&mut self, org_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Pathogen::VT_ORG_NAME, org_name);
  }
  #[inline]
  pub fn add_id_method(&mut self, id_method: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Pathogen::VT_ID_METHOD, id_method);
  }
  #[inline]
  pub fn add_culture_source(&mut self, culture_source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Pathogen::VT_CULTURE_SOURCE, culture_source);
  }
  #[inline]
  pub fn add_organism_type(&mut self, organism_type: u8) {
    self.fbb_.push_slot::<u8>(Pathogen::VT_ORGANISM_TYPE, organism_type, 0);
  }
  #[inline]
  pub fn add_report_date(&mut self, report_date: i64) {
    self.fbb_.push_slot::<i64>(Pathogen::VT_REPORT_DATE, report_date, 0);
  }
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Pathogen::VT_NOTES, notes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PathogenBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PathogenBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Pathogen<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BiologicalTestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BiologicalTest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BiologicalTest<'a> {
    type Inner = BiologicalTest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BiologicalTest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BiologicalTest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BiologicalTestArgs<'args>) -> flatbuffers::WIPOffset<BiologicalTest<'bldr>> {
      let mut builder = BiologicalTestBuilder::new(_fbb);
      builder.add_result(args.result);
      builder.add_test_date(args.test_date);
      if let Some(x) = args.test_category { builder.add_test_category(x); }
      if let Some(x) = args.ref_range { builder.add_ref_range(x); }
      if let Some(x) = args.unit { builder.add_unit(x); }
      if let Some(x) = args.test { builder.add_test(x); }
      builder.finish()
    }

    pub const VT_TEST_DATE: flatbuffers::VOffsetT = 4;
    pub const VT_TEST: flatbuffers::VOffsetT = 6;
    pub const VT_RESULT: flatbuffers::VOffsetT = 8;
    pub const VT_UNIT: flatbuffers::VOffsetT = 10;
    pub const VT_REF_RANGE: flatbuffers::VOffsetT = 12;
    pub const VT_TEST_CATEGORY: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn test_date(&self) -> i64 {
    self._tab.get::<i64>(BiologicalTest::VT_TEST_DATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn test(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BiologicalTest::VT_TEST, None)
  }
  #[inline]
  pub fn result(&self) -> f64 {
    self._tab.get::<f64>(BiologicalTest::VT_RESULT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn unit(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BiologicalTest::VT_UNIT, None)
  }
  #[inline]
  pub fn ref_range(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BiologicalTest::VT_REF_RANGE, None)
  }
  #[inline]
  pub fn test_category(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BiologicalTest::VT_TEST_CATEGORY, None)
  }
}

pub struct BiologicalTestArgs<'a> {
    pub test_date: i64,
    pub test: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub result: f64,
    pub unit: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub ref_range: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub test_category: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for BiologicalTestArgs<'a> {
    #[inline]
    fn default() -> Self {
        BiologicalTestArgs {
            test_date: 0,
            test: None,
            result: 0.0,
            unit: None,
            ref_range: None,
            test_category: None,
        }
    }
}
pub struct BiologicalTestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BiologicalTestBuilder<'a, 'b> {
  #[inline]
  pub fn add_test_date(&mut self, test_date: i64) {
    self.fbb_.push_slot::<i64>(BiologicalTest::VT_TEST_DATE, test_date, 0);
  }
  #[inline]
  pub fn add_test(&mut self, test: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BiologicalTest::VT_TEST, test);
  }
  #[inline]
  pub fn add_result(&mut self, result: f64) {
    self.fbb_.push_slot::<f64>(BiologicalTest::VT_RESULT, result, 0.0);
  }
  #[inline]
  pub fn add_unit(&mut self, unit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BiologicalTest::VT_UNIT, unit);
  }
  #[inline]
  pub fn add_ref_range(&mut self, ref_range: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BiologicalTest::VT_REF_RANGE, ref_range);
  }
  #[inline]
  pub fn add_test_category(&mut self, test_category: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BiologicalTest::VT_TEST_CATEGORY, test_category);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BiologicalTestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BiologicalTestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BiologicalTest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SubjectOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Subject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Subject<'a> {
    type Inner = Subject<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Subject<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Subject {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SubjectArgs<'args>) -> flatbuffers::WIPOffset<Subject<'bldr>> {
      let mut builder = SubjectBuilder::new(_fbb);
      builder.add_date_of_birth(args.date_of_birth);
      if let Some(x) = args.notes { builder.add_notes(x); }
      if let Some(x) = args.patient_biology { builder.add_patient_biology(x); }
      if let Some(x) = args.infection_data { builder.add_infection_data(x); }
      if let Some(x) = args.drug_data { builder.add_drug_data(x); }
      if let Some(x) = args.files { builder.add_files(x); }
      builder.add_gender(args.gender);
      builder.add_age(args.age);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_AGE: flatbuffers::VOffsetT = 6;
    pub const VT_DATE_OF_BIRTH: flatbuffers::VOffsetT = 8;
    pub const VT_GENDER: flatbuffers::VOffsetT = 10;
    pub const VT_FILES: flatbuffers::VOffsetT = 12;
    pub const VT_DRUG_DATA: flatbuffers::VOffsetT = 14;
    pub const VT_INFECTION_DATA: flatbuffers::VOffsetT = 16;
    pub const VT_PATIENT_BIOLOGY: flatbuffers::VOffsetT = 18;
    pub const VT_NOTES: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn id(&self) -> u8 {
    self._tab.get::<u8>(Subject::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn age(&self) -> i8 {
    self._tab.get::<i8>(Subject::VT_AGE, Some(0)).unwrap()
  }
  #[inline]
  pub fn date_of_birth(&self) -> i64 {
    self._tab.get::<i64>(Subject::VT_DATE_OF_BIRTH, Some(0)).unwrap()
  }
  #[inline]
  pub fn gender(&self) -> u8 {
    self._tab.get::<u8>(Subject::VT_GENDER, Some(0)).unwrap()
  }
  #[inline]
  pub fn files(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(Subject::VT_FILES, None)
  }
  #[inline]
  pub fn drug_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Drug<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Drug<'a>>>>>(Subject::VT_DRUG_DATA, None)
  }
  #[inline]
  pub fn infection_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pathogen<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Pathogen<'a>>>>>(Subject::VT_INFECTION_DATA, None)
  }
  #[inline]
  pub fn patient_biology(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BiologicalTest<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BiologicalTest<'a>>>>>(Subject::VT_PATIENT_BIOLOGY, None)
  }
  #[inline]
  pub fn notes(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Subject::VT_NOTES, None)
  }
}

pub struct SubjectArgs<'a> {
    pub id: u8,
    pub age: i8,
    pub date_of_birth: i64,
    pub gender: u8,
    pub files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub drug_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Drug<'a >>>>>,
    pub infection_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Pathogen<'a >>>>>,
    pub patient_biology: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BiologicalTest<'a >>>>>,
    pub notes: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for SubjectArgs<'a> {
    #[inline]
    fn default() -> Self {
        SubjectArgs {
            id: 0,
            age: 0,
            date_of_birth: 0,
            gender: 0,
            files: None,
            drug_data: None,
            infection_data: None,
            patient_biology: None,
            notes: None,
        }
    }
}
pub struct SubjectBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubjectBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u8) {
    self.fbb_.push_slot::<u8>(Subject::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_age(&mut self, age: i8) {
    self.fbb_.push_slot::<i8>(Subject::VT_AGE, age, 0);
  }
  #[inline]
  pub fn add_date_of_birth(&mut self, date_of_birth: i64) {
    self.fbb_.push_slot::<i64>(Subject::VT_DATE_OF_BIRTH, date_of_birth, 0);
  }
  #[inline]
  pub fn add_gender(&mut self, gender: u8) {
    self.fbb_.push_slot::<u8>(Subject::VT_GENDER, gender, 0);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subject::VT_FILES, files);
  }
  #[inline]
  pub fn add_drug_data(&mut self, drug_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Drug<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subject::VT_DRUG_DATA, drug_data);
  }
  #[inline]
  pub fn add_infection_data(&mut self, infection_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Pathogen<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subject::VT_INFECTION_DATA, infection_data);
  }
  #[inline]
  pub fn add_patient_biology(&mut self, patient_biology: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BiologicalTest<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subject::VT_PATIENT_BIOLOGY, patient_biology);
  }
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subject::VT_NOTES, notes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubjectBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Subject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

